# 예외 처리와 오류 페이지

---

## 서블릿 예외 처리 - 시작

서블릿은 2가지 방식으로 예외 처리를 지원한다.

+ `Exception`
+ `response.sendError(HTTP 상태 코드, 오류 메시지`)

---

### Exception

웹 애플리케이션은 사용자 요청별로 별도의 쓰레드가 할당되고, 서블릿 컨테이너 안에서 실행된다.

애플리케이션에서 예외가 터졌는데 잡지 못하고 서블릿 밖으로 예외가 전달되면 결국 톰캣 같은 WAS까지 예외가 전달된다.

```text
WAS <- 필터 <- 서블릿 <- 인터셉터 <- 컨트롤러(예외발생)
```

```java
    @GetMapping("/error-ex")
public void errorEx(){
        throw new RuntimeException("예외 발생!");
        }

```

`Exception`의 경우 서버 내부에서 처리할 수 없는 오류가 발생한 것으로 생각해 HTTP 상태 코드 500을 반환한다.

`HTTP Status 500 – Internal Server Error`

```java
    @GetMapping("/error-404")
public void error404(HttpServletResponse response)throws IOException{
        response.sendError(404,"404 오류!");
        }

@GetMapping("/error-500")
public void error500(HttpServletResponse response)throws IOException{
        response.sendError(500);
        }
```

`response.sendError(sc, msg)` 는 당장 예외가 발생하는 것은 아니지만 서블릿 컨테이너에게 오류가 발생했다고 전달할 수 있다.

---

## 서블릿 예외 처리 - 오류 화면 제공

서블릿은 `Exception`이 발생해서 서블릿 밖으로 전달되거나 `response.sendError()`가 호출되었을때 상황에 맞춘 오류 처리 기능을 제공한다.

---

### 서블릿 오류 페이지 등록

```java

@Component
public class WebServerCustomizer implements WebServerFactoryCustomizer<ConfigurableWebServerFactory> {
    @Override
    public void customize(ConfigurableWebServerFactory factory) {

        ErrorPage errorPage404 = new ErrorPage(HttpStatus.NOT_FOUND, "/error-page/404");
        ErrorPage errorPage500 = new ErrorPage(HttpStatus.INTERNAL_SERVER_ERROR, "/error-page/500");

        ErrorPage errorPageEx = new ErrorPage(RuntimeException.class, "/error-page/500");

        factory.addErrorPages(errorPage404, errorPage500, errorPageEx);
    }
}
```

`RuntimeException`의 경우엔 자식들도 함께 다 처리된다.

`addErrorPages`로 ErrorPage들을 등록하면 해당하는 예외나 `response`에 있는 error를 확인하고 해당 path를 호출한다.

```java

@Slf4j
@Controller
public class ErrorPageController {

    @RequestMapping("/error-page/404")
    public String errorPage404(HttpServletRequest request, HttpServletResponse response) {
        log.info("errorPage 404");

        return "error-page/404";

    }

    @RequestMapping("/error-page/500")
    public String errorPage500(HttpServletRequest request, HttpServletResponse response) {
        log.info("errorPage 500");

        return "error-page/500";

    }
}
```

```html
<!DOCTYPE HTML>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="utf-8">
</head>
<body>
<div class="container" style="max-width: 600px">
    <div class="py-5 text-center">
        <h2>404 오류 화면</h2>
    </div>
    <div>
        <p>오류 화면 입니다.</p>
    </div>
    <hr class="my-4">
</div> <!-- /container -->
</body>
</html>
```

```html
<!DOCTYPE HTML>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="utf-8">
</head>
<body>
<div class="container" style="max-width: 600px">
    <div class="py-5 text-center">
        <h2>500 오류 화면</h2>
    </div>
    <div>
        <p>오류 화면 입니다.</p>
    </div>
    <hr class="my-4">
</div> <!-- /container -->
</body>
</html>
```

---

## 서블릿 에외 처리 - 오류 페이지 작동 원리

서블릿은 `Exception`이 발생해서 서블릿 밖으로 전달되거나 `response.sendError()`가 호출되었을 때 설정된 오류 페이지를 찾는다.


---

**예외 발생 흐름**

```text
WAS(여기까지 전파) <- 필터 <- 서블릿 <- 인터셉터 <- 컨트롤러(예외발생)
```

**sendError 흐름**

```text
WAS(sendError 호출 기록 확인) <- 필터 <- 서블릿 <- 인터셉터 <- 컨트롤러(response.sendError())
```

WAS는 해당 예외를 처리하는 오류 페이지 정보를 확인한다.

`new ErrorPage(RuntimeException.class, "/error-page/500")`

확인해서 지정되어있는 오류 페이지가 있으면 페이지를 출력하기 위해 `/error-page/500`을 다시 요청한다.

**오류 페이지 요청 흐름**

```text
WAS `/error-page/500` 다시 요청 -> 필터 -> 서블릿 -> 인터셉터 -> 컨트롤러(/error-page/500) -> View
```

**예외 발생과 오류 페이지 요청 흐름**

```text
1. WAS(여기까지 전파) <- 필터 <- 서블릿 <- 인터셉터 <- 컨트롤러(예외발생)

2. WAS `/error-page/500` 다시 요청 -> 필터 -> 서블릿 -> 인터셉터 -> 컨트롤러(/error-page/500) -> View
```

여기서 웹(클라이언트)는 서버 내부에서 이런 일이 일어나는지 전혀 모른다. 오직 서버 내부에서 오류 페이지를 찾기 위해 추가적인 호출을 한다.

**오류 정보 추가**

WAS는 오류페이지를 단순히 다시 요청만 하는 것이 아니라 오류 정보를 `request`의 `attribute`에 추가해서 넘겨준다

```java

@Slf4j
@Controller
public class ErrorPageController {


    //RequestDispatcher 상수로 정의되어 있음
    public static final String ERROR_EXCEPTION = "javax.servlet.error.exception";
    public static final String ERROR_EXCEPTION_TYPE = "javax.servlet.error.exception_type";
    public static final String ERROR_MESSAGE = "javax.servlet.error.message";
    public static final String ERROR_REQUEST_URI = "javax.servlet.error.request_uri";
    public static final String ERROR_SERVLET_NAME = "javax.servlet.error.servlet_name";
    public static final String ERROR_STATUS_CODE = "javax.servlet.error.status_code";

    @RequestMapping("/error-page/404")
    public String errorPage404(HttpServletRequest request, HttpServletResponse response) {
        log.info("errorPage 404");
        printErrorInfo(request);
        return "error-page/404";

    }

    @RequestMapping("/error-page/500")
    public String errorPage500(HttpServletRequest request, HttpServletResponse response) {
        log.info("errorPage 500");
        printErrorInfo(request);
        return "error-page/500";
    }


    private void printErrorInfo(HttpServletRequest request) {
        log.info("ERROR_EXCEPTION: {}", request.getAttribute(ERROR_EXCEPTION));
        log.info("ERROR_EXCEPTION_TYPE: {}", request.getAttribute(ERROR_EXCEPTION_TYPE));
        log.info("ERROR_MESSAGE: {}", request.getAttribute(ERROR_MESSAGE));
        log.info("ERROR_REQUEST_URI: {}", request.getAttribute(ERROR_REQUEST_URI));
        log.info("ERROR_SERVLET_NAME: {}", request.getAttribute(ERROR_SERVLET_NAME));
        log.info("ERROR_STATUS_CODE: {}", request.getAttribute(ERROR_STATUS_CODE));

        log.info("dispatchType={}", request.getDispatcherType());
    }
}
```

+ javax.servlet.error.exception: 예외
+ javax.servlet.error.exception_type: 예외 타입
+ javax.servlet.error.message: 오류 메시지
+ javax.servlet.error.request_rui: 클라이언트 요청 URI
+ javax.servlet.error.servlet_name: 오류가 발생한 서블릿 이름
+ javax.servlet.error.status_code: HTTP 상태 코드

---

## 서블릿 예외 처리 - 필터

```text
1. WAS(여기까지 전파) <- 필터 <- 서블릿 <- 인터셉터 <- 컨트롤러(예외발생)

2. WAS `/error-page/500` 다시 요청 -> 필터 -> 서블릿 -> 인터셉터 -> 컨트롤러(/error-page/500) -> View
```

오류가 발생하면 오류페이지를 출력하기 위해 WAS 내부에서 다시 한 번 호출이 발생한다.

서버 내부에서 오류 페이지를 호출한다고 해서 해당 필터나 인터셉터가 한번 더 호출되는 것은 매우 비효율적이다.

결국 클라이언트로부터 발생한 정상 요청인지, 오류페이지를 출력하기 위한 내부요청인지 구분할 수 있어야 하는데 `DispatcherType`이 이러한 정보를 제공한다.


---

## DispatcherType

```java
public enum DispatcherType {
    FORWARD,
    INCLUDE,
    REQUEST,
    ASYNC,
    ERROR
}
```

```java
@Slf4j
public class LogFilter implements Filter {
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
        log.info("log filter init");
    }
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
        HttpServletRequest httpRequest = (HttpServletRequest) request;
        String requestURI = httpRequest.getRequestURI();
        String uuid = UUID.randomUUID().toString();
        try {
            log.info("REQUEST [{}][{}][{}]", uuid, request.getDispatcherType(), requestURI);
            chain.doFilter(request, response);
        } catch (Exception e) {
            log.info("EXCEPTION {}",e.getMessage());
            throw e;
        } finally {
            log.info("RESPONSE [{}][{}][{}]", uuid, request.getDispatcherType(), requestURI);
        }
    }
    @Override
    public void destroy() {
        log.info("log filter destroy");
    }
}
```


```java
@Configuration
public class WebConfig implements WebMvcConfigurer {

    @Bean
    public FilterRegistrationBean logFilter(){
        FilterRegistrationBean<Filter> filterRegistrationBean = new FilterRegistrationBean<>();

        filterRegistrationBean.setFilter(new LogFilter());
        filterRegistrationBean.setOrder(1);
        filterRegistrationBean.addUrlPatterns("/*");
        filterRegistrationBean.setDispatcherTypes(DispatcherType.REQUEST,DispatcherType.ERROR);

        return filterRegistrationBean;
    }
}
```

`filterRegistrationBean.setDispatcherTypes(DispatcherType.REQUEST,DispatcherType.ERROR);`로 설정하면 클라이언트 요청, 오류 페이지 요청에서 필터가 호출된다.

---

## 서블릿 예외 처리 - 인터셉터

---

```java
@Slf4j
public class LogInterceptor implements HandlerInterceptor {

    public static final String LOG_ID = "logId";

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse
            response, Object handler) throws Exception {
        String requestURI = request.getRequestURI();
        String uuid = UUID.randomUUID().toString();
        request.setAttribute(LOG_ID, uuid);
        log.info("REQUEST [{}][{}][{}][{}]", uuid, request.getDispatcherType(), requestURI, handler);
        return true;
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        log.info("postHandle [{}]", modelAndView);
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        String requestURI = request.getRequestURI();
        String logId = (String) request.getAttribute(LOG_ID);
        log.info("RESPONSE [{}][{}][{}]", logId, request.getDispatcherType(), requestURI);
        if (ex != null) {
            log.error("afterCompletion error!!", ex);
        }
    }
}
```

인터셉터는 필터와 달리 `DisaptcheType`에 따른 적용을 할 수 없다. 

대신에 `excludePathPatterns`를 사용하여 제외시켜주면 된다.

```java
@Configuration
public class WebConfig implements WebMvcConfigurer {

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new LogInterceptor())
                .order(1)
                .addPathPatterns("/**")
                .excludePathPatterns("/css/**", "*.ico", "/error", "/error-page/**");
    }
}
```

`/error-page/**`를 제외해서 `error-page/500`같은 내부 호출의 경우엔 인터셉터가 호출되지 않는다.


### error-ex로 오류 요청시 흐름

```text
1. WAS(/error-ex, dispatchType=REQUEST) -> 필터 -> 서블릿 -> 인터셉터 -> 컨트롤러
2. WAS(여기까지 전파) <- 필터 <- 서블릿 <- 인터셉터 <- 컨트롤러(예외발생)
3. WAS 오류 페이지 확인
4. WAS(/error-page/500, dispatchType=ERROR) -> 필터(x) -> 서블릿 -> 인터셉터(x) -> 컨트롤러(/error-page/500) -> View
```

---

## 스프링 부트 - 오류 페이지1

지금까지 예외 처리 페이지를 만들기 위해선 다음과 같은 과정을 거쳤다.

1. `WebServerCustomizer`생성
2. 예외 종류에 따라 `Errorpage`추가
3. 예외 처리용 컨트롤러 `ErrorPageController`를 만듦

---

### 스프링 부트는 이러한 과정을 모두 기본으로 제공한다.

+ `ErrorPage`를 자동으로 등록. 이때 `/error`라는 경로로 기본 오류 페이지를 설정
  + `new ErrorPage("/error")` 상태코드와 예외를 설정하지 않으면 기본 오류 페이지로 사용된다.
  + 서블릿 밖으로 예외가 발생하거나, `response.sendError()`가 호출되면 모든 오류는 `/error`를 호출한다.
+ `BasicErrorController`라는 스프링 컨트롤러를 자동으로 등록한다.
  + `ErrorPage`에서 등록한 `/error`를 매핑해서 처리하는 컨트롤러

개발자는 오류페이지만 만들어서 등록하면 된다.

```html
<!DOCTYPE HTML>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="utf-8">
</head>
<body>
<div class="container" style="max-width: 600px">
    <div class="py-5 text-center">
        <h2>4xx 오류 화면 스프링 부트 제공</h2>
    </div>
    <div>
        <p>오류 화면 입니다.</p>
    </div>
    <hr class="my-4">
</div> <!-- /container -->
</body>
</html>
```

```html
<!DOCTYPE HTML>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="utf-8">
</head>
<body>
<div class="container" style="max-width: 600px">
    <div class="py-5 text-center">
        <h2>404 오류 화면 스프링 부트 제공</h2>
    </div>
    <div>
        <p>오류 화면 입니다.</p>
    </div>
    <hr class="my-4">
</div> <!-- /container -->
</body>
</html>
```

```html
<!DOCTYPE HTML>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="utf-8">
</head>
<body>
<div class="container" style="max-width: 600px">
    <div class="py-5 text-center">
        <h2>500 오류 화면 스프링 부트 제공</h2>
    </div>
    <div>
        <p>오류 화면 입니다.</p>
    </div>
    <hr class="my-4">
</div> <!-- /container -->
</body>
</html>
```
### 뷰 선택우선순위

`BasicErrorController`의 처리 순서

1. 뷰 템플릿
  + `resources/templates/error/500.html`
  + `resources/templates/error/5xx.html`

2. 정적 리소스
  + `resources/static/error/400.html`
  + `resources/static/error/404.html`
  + `resources/static/error/4xx.html`

3. 적용 대상이 없을 때
  + `resources/templates/error.html`

구체적인 것이 더 우선순위가 높다.

---

## 스프링 부트 - 오류 페이지2

---

### BasicErrorController가 제공하는 기본 정보들

`BasicCErrorController` 컨트롤러는 다음 정보를 model에 담아서 뷰에 전달한다. 뷰 템플릿은 이 값을 활용해서 출력할 수 있다.


```text
* timestamp: Fri Feb 05 00:00:00 KST 2021
* status: 400
* error: Bad Request
* exception: org.springframework.validation.BindException
* trace: 예외 trace
* message: Validation failed for object='data'. Error count: 1
* errors: Errors(BindingResult)
* path: 클라이언트 요청 경로 (`/hello`)
```

```html
<!DOCTYPE HTML>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="utf-8">
</head>
<body>
<div class="container" style="max-width: 600px">
    <div class="py-5 text-center">
        <h2>500 오류 화면 스프링 부트 제공</h2>
    </div>
    <div>
        <p>오류 화면 입니다.</p>
    </div>

    <ul>
        <li>오류 정보</li>
        <ul>
            <li th:text="|timestamp: ${timestamp}|"></li>
            <li th:text="|path: ${path}|"></li>
            <li th:text="|status: ${status}|"></li>
            <li th:text="|message: ${message}|"></li>
            <li th:text="|error: ${error}|"></li>
            <li th:text="|exception: ${exception}|"></li>
            <li th:text="|errors: ${errors}|"></li>
            <li th:text="|trace: ${trace}|"></li>
        </ul>
    </ul>
    <hr class="my-4">
</div> <!-- /container -->
</body>
</html>
```

`application.properties`에서 오류정보를 `model` 포함할지 선택할 수 있다.

```text
server.error.include-exception=false : exception 포함 여부( true , false )
server.error.include-message=never : message 포함 여부
server.error.include-stacktrace=never : trace 포함 여부
server.error.include-binding-errors=never : errors 포함 여부
```

```text
server.error.include-exception=true
server.error.include-message=on_param
server.error.include-stacktrace=on_param
server.error.include-binding-errors=on_param
```

+ `never`: 사용하지 않음
+ `always`: 항상 사용
+ `on_param`: 파라미터가 있을 때 사용

### 스프링 부트 오류 관련 옵션

`server.error.whitelabel.enabled=true`: 오류 처리 화면을 못 찾을 시 whitelabel 오류 페이지 적용

`server.error.path=/error`: 오류 페이지 경로, 스프링이 자동으로 등록하는 서블릿 글로벌 오류 페이지 경로와 `BasicErrorController`오류 컨트롤러 경로에 함께 사용된다.




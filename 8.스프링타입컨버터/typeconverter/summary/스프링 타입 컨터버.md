# 스프링 타입 컨버터

---

## 스프링 타입 컨버터 소개

문자를 숫자로 변환하거나, 숫자를 문자로 변환하는 것 처럼 애플리케이션을 개발하다 보면 타입을 변환해야 하는 경우가 상당히 많다.

---

```java
@RestController
public class HelloController {
    
    @GetMapping("/hello-v1")
    public String helloV1(HttpServletRequest request){
        String data = request.getParameter("data");
        Integer intValue = Integer.valueOf(data);
        System.out.println("intValue = " + intValue);
        return "ok";
    }
}
```

`http://localhost:8080/hello-v1?data=10`

```text
intValue = 10
```

HTTP 요청 파라미터는 모두 문자로 처리된다. 따라서 파라미터를 자바에서 다른 타입으로 변환해서 사용하고 싶으면 변환하는 과정을 거쳐야 한다.

```java
    @GetMapping("/hello-v2")
    public String helloV2(@RequestParam Integer data){
        System.out.println("data = " + data);
        return "ok";
    }
```
스프링 MVC가 제공하는 `@RequestParam`은 파라미터로 바로 받을 수 있다.

`http://localhost:8080/hello-v2?data=10`

```text
data = 10
```

이렇게 바로 받을 수 있는 이유는 **스프링이 중간에서 타입을 변환**해주었기 때문이다.

`@ModelAttribute`나 `@PathVariable`도 마찬가지이다.

만약 개발자가 새로운 타입을 만들어서 변환하고 싶을 때 컨버터 인터페이스를 구현해서 등록하면 된다.

---

## 타입 컨버터 - Converter


```java
@Slf4j
public class IntegerToStringConverter implements Converter<Integer, String> {
    @Override
    public String convert(Integer source) {
        log.info("convert source={}", source);
        return String.valueOf(source);
    }
}
```

```java
@Slf4j
public class StringToIntegerConverter implements Converter<String,Integer> {
    @Override
    public Integer convert(String source) {
        log.info("convert source={}", source);
        return Integer.valueOf(source);
    }
}
```

```java
public class ConverterTest {

    @Test
    void stringToInteger() {
        StringToIntegerConverter converter = new StringToIntegerConverter();
        Integer result = converter.convert("10");
        assertThat(result).isEqualTo(10);
    }

    @Test
    void IntegerToString() {
        IntegerToStringConverter converter = new IntegerToStringConverter();
        String result = converter.convert(10);
        assertThat(result).isEqualTo("10");
    }
}
```

```java
@Getter
@EqualsAndHashCode
public class IpPort {
    private String ip;
    private int port;

    public IpPort(String ip, int port) {
        this.ip = ip;
        this.port = port;
    }
}
```


```java
@Slf4j
public class IpPortToStringConverter implements Converter<IpPort, String> {
    @Override
    public String convert(IpPort source) {
        log.info("convert source={}", source);

        //IpPort 객체 -> "127.0.0.1";

        return source.getIp() + ":" + source.getPort();
    }
}
```

```java
@Slf4j
public class StringToIpPortConverter implements Converter<String, IpPort> {
    @Override
    public IpPort convert(String source) {
        log.info("convert source={}", source);
        //"127.0.0.1:8080"
        String[] split = source.split(":");
        String ip = split[0];
        int port = Integer.parseInt(split[1]);

        return new IpPort(ip,port);
    }
}
```

```java
public class ConverterTest {
    
    @Test
    void IpPortToString(){
        IpPortToStringConverter converter = new IpPortToStringConverter();
        IpPort source = new IpPort("127.0.0.1", 8080);
        String result = converter.convert(source);
        assertThat(result).isEqualTo("127.0.0.1:8080");
    }


    @Test
    void StringToIpPort(){
        StringToIpPortConverter converter = new StringToIpPortConverter();
        String source = "127.0.0.1:8080";
        IpPort result = converter.convert(source);
        assertThat(result).isEqualTo(new IpPort("127.0.0.1",8080));
    }
}
```

위처럼 타입 컨버터를 하나하나 직접 사용하면, 개발자가 직접 컨버팅 하는 것과 다를게 없다.

타입 컨버터를 등록하고 관리하면서 기능을 제공하는 무언가가 필요하다.

> 참고
> 
> 스프링은 용도에 따라 다양한 방식의 타입 컨버터를 제공한다.
> 
> `Converter` -> 기본 타입 컨버터
> 
> `ConverterFactory` -> 전체 클래스 계층 구조가 필요할 때
> 
> `GenericConverter` -> 정교한 구현, 대상 필드의 애노테이션 정보 사용 가능
> 
> `ConditionalGenericConverter` -> 특정 조건이 참인 경우에만 실행

---

## 컨버전 서비스 - ConversionService

스프링이 제공하는 `ConversionService`는 개별 컨버터들을 모아 묶어서 편리하게 사용할 수 있는 기능을 제공한다.

---

```java
public class ConversionServiceTest {

    @Test
    void conversionService() {
        //등록
        DefaultConversionService conversionService = new DefaultConversionService();
        conversionService.addConverter(new StringToIntegerConverter());
        conversionService.addConverter(new IntegerToStringConverter());
        conversionService.addConverter(new StringToIpPortConverter());
        conversionService.addConverter(new IpPortToStringConverter());

        //사용
        assertThat(conversionService.convert("10", Integer.class)).isEqualTo(10);
        assertThat(conversionService.convert(10, String.class)).isEqualTo("10");

        IpPort ipPort = conversionService.convert("127.0.0.1:8080", IpPort.class);
        assertThat(ipPort).isEqualTo(new IpPort("127.0.0.1",8080));

        String ipPortString = conversionService.convert(new IpPort("127.0.0.1", 8080), String.class);
        assertThat(ipPortString).isEqualTo("127.0.0.1:8080");
    }
}
```

**등록과 사용 분리**

컨버터를 등록할 때는 타입 컨버터를 명확하게 알아야 하지만 사용하는 입장에서는 컨버터를 전혀 몰라도 된다.

타입 변환을 원하는 사용자는 컨버전 서비스 인터페이스에만 의존하면 된다.

`DefaultConversionService`는 다음 두 인터페이스를 구현했다.

+ `ConversionService`: 사용에 초점
+ `ConverterRegistry`: 등록에 초점

인터페이스를 분리하면 컨버터를 사용하는 클라이언트는 `ConversionService`만 의존하면 되므로 컨버터를 어떻게 등록하고 관리하는지 몰라도 된다.

스프링 내부에서는 `ConversionService`를 사용해서 타입을 변환한다. 

---

## 스프링에 Converter 적용하기

---

```java
@Configuration
public class WebConfig implements WebMvcConfigurer {

    @Override
    public void addFormatters(FormatterRegistry registry) {
        registry.addConverter(new StringToIntegerConverter());
        registry.addConverter(new IntegerToStringConverter());
        registry.addConverter(new StringToIpPortConverter());
        registry.addConverter(new IpPortToStringConverter());
    }
}
```

WebConfig에 converter 등록

```java
    @GetMapping("/ip-port")
    public String ipPort(@RequestParam IpPort ipPort){
        System.out.println("ipPort IP = " + ipPort.getIp());
        System.out.println("ipPort PORT= " + ipPort.getPort());

        return "ok";
    }
```

`http://localhost:8080/ip-port?ipPort=127.0.0.1:8080`

결과

```text
INFO 14232 --- [nio-8080-exec-1] h.t.converter.StringToIpPortConverter    : convert source=127.0.0.1:8080

ipPort IP = 127.0.0.1
ipPort PORT= 8080
```

---

## 뷰 템플릿에 컨버터 적용하기

타임리프는 렌더링 시 컨버터를 적용해서 렌더링 하는 방법을 편리하게 지원한다.

---

```java
@Controller
public class ConverterController {

    @GetMapping("/converter-view")
    public String converterView(Model model){
        model.addAttribute("number",10000);
        model.addAttribute("ipPort",new IpPort("127.0.0.1",8080));
        return "converter-view";
    }
}
```

```html
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<ul>
    <li>${number}: <span th:text="${number}" ></span></li>
    <li>${{number}}: <span th:text="${{number}}" ></span></li>
    <li>${ipPort}: <span th:text="${ipPort}" ></span></li>
    <li>${{ipPort}}: <span th:text="${{ipPort}}" ></span></li>
</ul>
</body>
</html>
```

```text
${number}: 10000
${{number}}: 10000
${ipPort}: hello.typeconverter.type.IpPort@59cb0946
${{ipPort}}: 127.0.0.1:8080


INFO 11288 --- [nio-8080-exec-8] h.t.converter.IntegerToStringConverter   : convert source=10000
INFO 11288 --- [nio-8080-exec-8] h.t.converter.IpPortToStringConverter    : convert source=hello.typeconverter.type.IpPort@59cb0946
```

타임리프는 `${{...}}`을 사용하면 자동으로 컨버전 서비스를 사용해서 변환된 결과를 출력해준다.


**변수 표현식**: `${...}`

**컨버전 서비스 사용**: `${{...}}`

`${{ipPort}}`의 경우 String 타입으로 변환해야 하기 때문에 `IpPortToStringConverter`가 적용된다.


### 폼에 적용하기

```java
@Controller
public class ConverterController {

    @GetMapping("/converter-view")
    public String converterView(Model model){
        model.addAttribute("number",10000);
        model.addAttribute("ipPort",new IpPort("127.0.0.1",8080));
        return "converter-view";
    }

    @GetMapping("/converter/edit")
    public String converterForm(Model model){
        IpPort ipPort = new IpPort("127.0.0.1", 8080);
        Form form = new Form(ipPort);
        model.addAttribute("form",form);

        return "converter-form";
    }

    @PostMapping("/converter/edit")
    public String converterEdit(@ModelAttribute Form form, Model model){
        IpPort ipPort = form.getIpPort();
        model.addAttribute("ipPort",ipPort);

        return "converter-view";
    }

    
    @Data
    static class Form{
        private IpPort ipPort;

        public Form(IpPort ipPort){
            this.ipPort = ipPort;
        }
    }
}
```

```html
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<form th:object="${form}" th:method="post">
    th:field <input type="text" th:field="*{ipPort}"><br/>
    th:value <input type="text" th:value="*{ipPort}">(보여주기 용도)<br/>
    <input type="submit"/>
</form>
</body>
</html>
```

`th:field`는 `id`,`name`,`value` 등 여러가지를 출력하는 기능이 있는데 컨버전 서비스도 함께 적용된다.

`th:field=127.0.0.1:8080`

`th:value=hello.typeconverter.type.IpPort@59cb0946`

`GET /converter/edit`

+ `th:field`가 자동으로 컨버전 서비스를 적용해주어서 `${{ipPort}}`처럼 적용이 되었다.

`POST /converter/edit`

+ `@ModelAttribute`를 사용해서 `String`을 `IpPort`로 변환한다.

---

## 포맷터 - Formatter

`Converter`는 입력과 출력 타입에 제한이 없는, 범용 타입 변환 기능을 제공한다.

**웹 애플리케이션에서 객체를 문자로, 문자를 객체로 변환하는 예**

+ `Integer`-> `String` 출력 시점에 숫자 `1000` -> 문자 `"1,000"` 단위에 맞는 쉼표를 넣어 출력하거나 숫자로 변경해야 한다.

이렇게 객체를 특정한 포맷에 맞추어 문자로 출력하거나 그 반대의 역할을 하는 것에 특화된 기능이 포맷터(`Fomatter`)이다.

---

### Converter Vs Formatter

+ `Converter`는 범용
+ `Formatter`는 문자에 특화


### 포맷터 - Formatter 만들기

포맷터`(`Formatter`)는 객체를 문자로 변경하고, 문자를 객체로 변경하는 두 가지 기능을 모두 제공한다.

+ `String print(T object, Locale locale)` : 객체를 문자로
+ `T parse(String text, Locale locale)` : 문자를 객체로

```java
@Slf4j
public class MyNumberFormatter implements Formatter<Number> {
    @Override
    public Number parse(String text, Locale locale) throws ParseException {
        log.info("text={}, locale={}", text,locale);
        //"1,000" -> 1000
        NumberFormat format = NumberFormat.getInstance(locale);
        return format.parse(text);
    }

    @Override
    public String print(Number object, Locale locale) {
        log.info("object={}, locale={}", object,locale);
        return NumberFormat.getInstance(locale).format(object);
    }
}
```

```java
class MyNumberFormatterTest {

    MyNumberFormatter formatter = new MyNumberFormatter();

    @Test
    void parse() throws ParseException {
        Number result = formatter.parse("1,000", Locale.KOREA);
        assertThat(result).isEqualTo(1000L);
    }

    @Test
    void print() {
        String result = formatter.print(1000, Locale.KOREA);
        assertThat(result).isEqualTo("1,000");
    }
}
```

---

## 포맷터를 지원하는 컨버전 서비스

컨버전 서비스에는 포맷터를 등록할 수 없다. 포맷터를 지원하는 컨버전 서비스를 사용하면 컨버전 서비스에 포맷터를 추가할 수 있다.

내부에서 어댑터 패턴을 사용해서 `Formatter`가 `Converter`처럼 동작하도록 지원한다.

`FormattingConversionService`는 포맷터를 지원하는 컨버전 서비스이다.

`DefaultFormattingConversionService`는 `FormattingConversionService`에 기본적인 통화, 숫자 관련된 몇가지 기본 포맷터를 제공한다.

---

```java
public class FormattingConversionServiceTest {

    @Test
    void formattingConversionService(){
        DefaultFormattingConversionService conversionService = new DefaultFormattingConversionService();
        //컨버터 등록
        conversionService.addConverter(new StringToIpPortConverter());
        conversionService.addConverter(new IpPortToStringConverter());

        //포맷터 등록
        conversionService.addFormatter(new MyNumberFormatter());

        //컨버터 사용
        IpPort ipPort = conversionService.convert("127.0.0.1:8080", IpPort.class);
        assertThat(ipPort).isEqualTo(new IpPort("127.0.0.1",8080));


        //포맷터 사용
        String convert = conversionService.convert(1000, String.class);
        assertThat(convert).isEqualTo("1,000");
    }
}
```

---

## 포맷터 적용하기

---

```java
@Configuration
public class WebConfig implements WebMvcConfigurer {

    @Override
    public void addFormatters(FormatterRegistry registry) {
        //registry.addConverter(new StringToIntegerConverter());
        //registry.addConverter(new IntegerToStringConverter());

        registry.addConverter(new StringToIpPortConverter());
        registry.addConverter(new IpPortToStringConverter());

        registry.addFormatter(new MyNumberFormatter());
    }
}

```

위에 주석처리 한 이유는 우선순위가 컨버터가 더 높기때문에 포맷터는 적용이 안된다.

---

## 스프링에 제공하는 기본 포맷터

스프링은 자바에서 기본으로 제공하는 타입들에 대해 수 많은 포맷터를 기본으로 제공한다.

애노테이션 기반으로 원하는 형식을 지정해서 사용할 수 있는 매우 유용한 포맷터 두 가지를 기본으로 제공한다.

---

`@NumberFormat`: 숫자 관련 형식 지정 포맷터 사용, `NumberFormatAnnotationFormatterFactory`

`@DataTimeFormat`: 날짜 관련 형식 지정 포맷터 사용


```java
@Controller
public class FormatterController {

    @GetMapping("/formatter/edit")
    public String formatterForm(Model model){
        Form form = new Form();

        form.setNumber(10000);
        form.setLocalDateTime(LocalDateTime.now());
        model.addAttribute("form",form);

        return "formatter-form";
    }

    @PostMapping("/formatter/edit")
    public String formatterEdit(@ModelAttribute Form form){
        return "formatter-view";
    }

    @Data
    static class Form{

        @NumberFormat(pattern = "###,###")
        private Integer number;

        @DateTimeFormat(pattern = "yyyy-MM-dd HH:mm:ss")
        private LocalDateTime localDateTime;
    }

}
```
애노테이션에 pattern을 지정해서 해당 포맷으로 출력이 가능하다.

```html
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<ul>
    <li>${form.number}: <span th:text="${form.number}"></span></li>
    <li>${{form.number}}: <span th:text="${{form.number}}"></span></li>
    <li>${form.localDateTime}: <span th:text="${form.localDateTime}"></span></li>
    <li>${{form.localDateTime}}: <span th:text="${{form.localDateTime}}"></span></li>
</ul>
</body>
</html>
```

```html
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<form th:object="${form}" th:method="post">
    number <input type="text" th:field="*{number}"><br/>
    localDateTime <input type="text" th:field="*{localDateTime}"><br/>
    <input type="submit"/>
</form>
</body>
</html>
```

```text
${form.number}: 10000
${{form.number}}: 10,000
${form.localDateTime}: 2022-03-18T16:26:23
${{form.localDateTime}}: 2022-03-18 16:26:23
```
지정한 포맷으로 잘 설정된다.